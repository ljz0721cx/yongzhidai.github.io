<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数字货币其实没那么牛逼]]></title>
    <url>%2F2018%2F01%2F19%2Fszhbmnmnb%2F</url>
    <content type="text"><![CDATA[自己一直在北京，从事互联网技术相关的工作。最近，老家里的几个亲戚朋友，向我咨询：比特币是咋回事，什么是去中心化，为什么那么赚钱。 人啊就是这样，看着别人赚钱，自己就跃跃欲试。 以比特币为代表的数字货币，被贴上各种牛逼的标签。本人不才，只想简单地谈谈，在我看来，这些牛逼的标签是不是真的牛逼。 在正式谈这些牛逼的标签之前，我先说一说：什么是财富？ 财富与货币的关系现实生活中，相当一部分人，把货币(钱)和财富等同为一个东东。但我这里可以向上帝保证：货币（钱）不是财富！ 货币只是用来度量财富和交易财富的工具，我们可以简单的把货币看作是，人类挑选出来的作为财富的代表。 既然货币是财富的代表，那最好的状态就是一一对应，即一个单位的财富对应一个单位的货币。 当然这只是理论上，现实中不可能达到一比一的比例的。一方面人类在不停地创造财富和消耗财富；另一方面人类也需要根据社会经济情况，适当调整货币和财富的比例。比如，经济不好的时候，人类会通过适当将增加货币的比例，来促进经济发展，也就是适当的通货膨胀。经济过热时，人类可以适当降低货币的比例，从而抑制经济过热而出现泡沫，也就是所谓的适当通货紧缩。 财富和货币的关系，可以很形象的看作是：主人跟狗的关系。财富就是主人，货币就是狗。狗总是跟着主人走，时而走在主人前边，时而走在主人后边，但不能脱离太远。狗适当走在前边，就是适当通货膨胀，督促主人加快点步伐。如果狗走的前边太远，那就面临走丢的风险，对应成货币就是：货币要变的一文不值了。 从社会中的财富总量来说，财富总是随着人类的辛勤努力，慢慢的在增加，很难突然瞬间财富爆膨。所以，能够被用来作为财富代表的物品中，需满足这么几个特点： 较为稀有，不能瞬间产生很多，也不能少的可怜 比较容易保存和交换 这也就应了马克思说的：金银天然不是货币，但货币天然是金银。金银就是地球上的一种金属而已，并非生来就是货币。但由于它具有货币的这两个性质，而被人类规定为货币。 为什么人类历史上没有使用石头做货币呢？当然是因为石头太多了嘛。石头想要多少，几乎瞬间就能找到多少。跟财富的量，完全不成比例。如果脑洞一下，古代朝廷强制用石头做货币，会怎么样呢？那肯定是，我拉好几车的石头，来跟你交换一粒大米。 说清楚财富和货币的关系，接下来就可以说说，为众人所疯狂且津津乐道的，那几个数字货币的牛逼标签。 去中心化数字货币，号称是一个去中心化的货币体系，没有中央银行，是安全和自由的保证。这是相较于现有的法定货币来说的一大特点。 现有的法定货币体系，是基于信用的货币体系，由各国的中央银行来控制管理。在更朝换代或者经济出现大危机时，确实会让人的财富存在安全问题；以及央行的监管，也会让贪污或者洗钱行为，变得不自由。但对于最广大的人民群众和现在这样的和平年代，其实并没有因为中心化，而那么的没安全感和缺乏自由。因为，政府虽然会有时出现偏差，但总的来说它还是要为整个国家和人民负责的。而且政府可以适当控制法定货币的比例，以起到“劫富济贫”的效果，这点是去中心化没法做到的。 在《数字货币因何而值十万块》中，我也说到了，数字货币跟黄金很像，这里不妨拿黄金来举例。 在我国古代，使用金银作为货币的时期，其本身也是一种去中心化的。只要金银在手，即便是更朝换代，也是安全和自由的，与朝廷没任何关系。 但财富总是遵循二八定律，总有一小部分人，持有大量的金银。在只接受金银进行纳税的朝廷，穷人只能卖掉粮食来纳税。所以当时也会有一帮掌握金银的财团，在秋收之际，囤积金银，哄抬金银价格，来掠取财富。朝廷也往往难以干预。 所以我想说：对我们最为广大的人民群众来说，中心化，有一个负责任的政府监管，反而才是自由和安全的。去中心化，反而并没有想的那么美好。 抗通胀数字货币说自己扛通胀，比如比特币，总共就只有2100万枚，听起来似乎比黄金还稀缺。而相较于法定货币，央行确实想印多少有多少。 还是拿黄金类比。在布雷顿森林体系解体之后，黄金就永远的退出了人类货币的历史舞台，被窖藏在了底下金库。或许黄金现在还很值钱，但它不再是货币。 在上文也说了，货币的量总是围绕着财富的量按照一定的比例上下波。黄金退出货币的历史舞台，或许有一定原因是交易不如纸币方便，但主要是，黄金无法跟进入现代化社会后财富的创造量相适应。 以比特币为代表的数字货币也比较稀缺，所以我认为，它根本不可能成为货币。 比特币是不是真的稀缺呢，只能是在比特币这条区块链上稀缺。但是人类可以开发无数个类似于比特币这样的区块链，风险可见一斑。 数字货币主打的抗通胀，确实没问题。通胀确实可以洗劫人们积累的财富。但适当通胀，并没有那么可怕，有时经济的发展就需要一定的通胀来促进。 以数字货币的稀缺性，反而更容易导致通缩。大家都觉着通胀可怕，其实通缩一定也不比通胀差。 通缩，也就是货币升值，大家更容易囤积货币，抑制消费，反而更不利于经济发展。 通缩其实也是一种掠夺财富的方式。通缩时，只要持有货币，就可坐等分享别人努力创造的财富。举个简单地例子，把北京的房子看作是货币，你只要持有北京的房子，每天喝喝茶听听戏，就能轻松身价成百上千万。哪些每天朝九晚九，辛勤为社会创造财富的人，其实在为你打工。 再形象点说：假如你有一个苹果和一块钱，我也有一个苹果和一块钱，我可以用一块钱买你的苹果，同样你也可以买我的苹果。这里钱就是货币，苹果就是财富。假如你通过努力，自己又创造了俩苹果。这时你我总共有四个苹果和两块钱，于是通货紧缩，货币升值为，一块钱可以买俩苹果。 在这个过程中，可以看得出来，我啥也没干，手里就由两个苹果(一个苹果+一块钱买到的一个苹果)变成了三个苹果(一个苹果+一块钱买到的两个苹果)。 总结其实，去中心化，也并不是那么完美无缺，如果没有靠谱的监管，其实更容易沦落为富人洗劫穷人财富的工具。 通胀确实可怕，它会稀释你积攒的财富；但是，通缩同样不可忽视，它会掠夺你正在努力创造的财富。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>数字货币</tag>
        <tag>通货膨胀</tag>
        <tag>通货紧缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字货币因何而值十万块]]></title>
    <url>%2F2018%2F01%2F15%2Fszhbyhezsw%2F</url>
    <content type="text"><![CDATA[最近，数字货币真的是火的不行，不管是叔叔阿姨，还是爷爷奶奶，张口都能唠上几句：区块链啊、去中心化啊。 还记得当年的柯达胶卷吧，自从数字摄影技术普及之后，这家公司就半死不活，行将就木，一度淡出公众视野。可就在最近，柯达宣布进入区块链之后，股价更是翻了一倍，就是这么神奇。甚至有些公司，仅仅是将公司名字加上“区块链”几个字，股价就跟脱缰了的野马，一发不可收拾。疯狂到如此程度，不免让人想起当年的郁金香泡沫。 但虚拟币到底有什么价值？为什么比特币超过十万一枚？区块链是什么高深技术吗？普通人要不要参与这个趋势发点财呢？接下来我就聊一聊我个人看法。 首先，先梳理下什么是货币。货币可以被定义为：大部分人都愿意接受的，用来物物交换的中介物，即一般等价物。马克思说：金银天然不是货币，但货币天然是金银。货币为什么天然就是金银呢？是因为在人类的慢慢历史长河中，金银由于其稀缺性，易于储存等性质，而被人类筛选出来作为了货币。 不知道你有没有思考过，黄金到底有什么价值？耗费大量的人力物力，把黄金开采锻造出来，然后放到消耗巨大财力而修建的地下金库中，还要安排人员轮流看守。黄金不但没有创造价值，而且还在消耗价值。而即便是一块很不起眼的土地，我们都可以通过种植庄家产生价值。想必这也是当初哪些聪明的地主，宁愿把黄金换成土地，也不愿意一直保留黄金的原因吧。 但为啥大家还对黄金这么趋之若鹜呢？主要两点：稀缺性和大部分人都愿意接受它。 黄金的稀缺性是客观存在的事实，大家都愿意接受它是一个慢慢的发展的过程。与以比特币为代表的虚拟币类比，比特币由于其设计，也具有稀缺性，同时由于洗钱啊、赌博啊、投机炒作啊等，而慢慢的在人群中变得越来越被接受。所以比特币其实是跟黄金类似的东西。当你再疑惑虚拟币到底有什么价值时，不妨先问问自己，黄金有什么价值。 但要强调的是，我只是说黄金和虚拟币类似，而不是完全相同，因为我能想到，有一部分人肯定拿黄金可以做首饰，还可以做芯片来反驳我。关于这点的区别我不想多说，我更想说另一个最大的区别：黄金没法被人类复制，地球上有多少黄金就是多少黄金，人类没法再复制出黄金2号、黄金2号。但是虚拟币不同，虽然在比特币这个区块链上，比特币的数量是稀缺没法复制的，但是人类可以再开发出比特币2号，比特币3号，只要你愿意，就可以这么无穷无尽的开发下去。某一区块链上的虚拟货币是稀缺的，但是区块链并不稀缺。 既然区块链可以无穷无尽的开发复制下去，那自然也能出现越来越多种类的虚拟货币。那在这些种类的虚拟货币中，哪个更值钱呢？很简单：哪个玩家多哪个更值钱。 比特币当下已达到十万多人民币一枚，之所以达到这么高的价格，除了每个区块链上的货币都会有的稀缺性外，最重要的还是，由于其出现最早、时间最长，参与的玩家最多。那比特币到底值不值十万多一枚呢？这个真不好说，我个人更倾向于有泡沫，与最近区块链、虚拟币等概念被炒得太热，大家都挤破头的参与进来，想投机发财有关。如果有一天，有人开发出比特币2号，大家都来玩这个了，那现在的比特币将会变得一文不值。 再说说区块链，区块链是新的高深的技术吗？作为一个技术研发人员，可以非常肯定的告诉你：并不是。区块链更多的是一种新的架构思想或者是一种新的设计方案。它所用到的技术，大多数人都多少接触过： 有没有用看快播看过片啊？看过吧，用到了这里的点对点网络技术。有没有用过银行的U盾啊？用过吧，用到了这里的加密、数字签名的技术。作为技术人员，尤其是互联网从业者，肯定也用过分布式系统吧。所以说，区块链技术并不高深，只是设计的巧妙而已。当然我这里并不是说实现起来简单，仅仅是说采用的技术不是很顶尖很有突破。 虚拟币值不值钱，就看有没有人愿意玩它。但是虚拟币的底层技术，区块链不同。区块链还是有一定的商业用价值的，比如我们阿里内部，就在应用区块链技术，来实现商品溯源。 现在关于区块链的新闻真是漫天飞舞：什么那几家大型银行投资区块链，什么那几个大型互联网公司布局区块链，还有什么天使基金、风险投资投资区块链啊。似乎区块链真的是一场改变世界的大革命一样，各种牛逼人物、机构纷纷参与。但普通人的你我，不能因为这些大佬们的参与，而失去理智。有一点我觉着有责任对不了解区块链的人说清楚：这些大佬本投资区块链，是看重这块技术对未来商业所产生的价值，并不是投资购买虚拟币。切莫不管三七二十一，冲进去就是买各种币。 最后再说一说，普通人要不要参与进来，顺势赚点钱呢。我觉着吧，可以适当参与，但不能all in。 虚拟币其实也不是某些人认为的庞氏骗局，它更多的像是我上边分析的那样，类黄金的东西。只要它有一定的稀缺性，有人接受它，它就有可能会升值会贬值。所以你可以拿出一定比例的收入，当成资产配置一样配置一些。但是前提一定得了解这个项目。毕竟也会有一大部分骗子，打着区块链、虚拟币的幌子，通过一个描述的很美好的白皮书，进行ICO，骗取哪些啥都不懂，是区块链就上的人的钱财。 所以，投资区块链，最重要的是看项目。看看项目的发起人是否真的有相关的工作背景以及技术背景。还要看看这个项目未来商用性，能否吸引用户来玩，只有未来有人玩了，它才可能值钱有价值，否则什么都不是。再就是通过技术的角度评估其技术上的可行性，这点可能对普通人来说比较有门槛，可以找懂技术的人进行咨询。 本篇就聊到这吧，回头找时间，我再从程序员的视角，聊聊区块链具体底层的技术实现。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写把”锁”之---终极篇]]></title>
    <url>%2F2018%2F01%2F10%2Fjava-loc5%2F</url>
    <content type="text"><![CDATA[锁是整个Java并发包的实现基础，通过学习本系列文章，将对你理解Java并发包的本质有很大的帮助。 前边几篇中，我已经把实现锁用到的技术，进行了一一讲述。这其中有原子性、内存模型、LockSupport还有CAS，掌握了这些技术，即使没有本篇，你也完全有能力自己写一把锁出来。但为了本系列的完整性，我在这里还是把最后这一篇补上。 先说一下锁的运行流程：多个线程抢占同一把锁，只有一个线程能抢占成功，抢占成功的线程继续执行下边的逻辑，抢占失败的线程进入阻塞等待。抢占成功的线程执行完毕后，释放锁，并从等待的线程中挑一个唤醒，让它继续竞争锁。 转变成程序实现：我们首先定一个state变量，state=0表示未被加锁，state=1表示被加锁。多个线程在抢占锁时，竞争将state变量从0修改为1，修改成功的线程则加锁成功。state从0修改为1的过程，这里使用cas操作，以保证只有一个线程加锁成功，同时state需要用volatile修饰，已解决线程可见的问题。加锁成功的线程执行完业务逻辑后，将state从1修改回0，同时从等待的线程中选择一个线程唤醒。所以加锁失败的线程，在加锁失败时需要将自己放到一个集合中，以等待被唤醒。这个集合需要支持多线程并发安全，在这里我通过一个链表来实现，通过CAS操作来实现并发安全。 把思路说清楚了，咱们看下代码实现。 首先咱们实现一个ThreadList，这是一个链表结合，用来存放等待的处于等待唤醒的线程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ThreadList&#123; private volatile Node head = null; private static long headOffset; private static Unsafe unsafe; static &#123; try &#123; Constructor&lt;Unsafe&gt; constructor = Unsafe.class.getDeclaredConstructor(new Class&lt;?&gt;[0]); constructor.setAccessible(true); unsafe = constructor.newInstance(new Object[0]); headOffset = unsafe.objectFieldOffset(ThreadList.class.getDeclaredField(&quot;head&quot;)); &#125;catch (Exception e)&#123; &#125; &#125; /** * * @param thread * @return 是否只有当前一个线程在等待 */ public boolean insert(Thread thread)&#123; Node node = new Node(thread); for(;;)&#123; Node first = getHead(); node.setNext(first); if(unsafe.compareAndSwapObject(this, headOffset,first,node))&#123; return first==null?true:false; &#125; &#125; &#125; public Thread pop()&#123; Node first = null; for(;;)&#123; first = getHead(); Node next = null; if(first!=null)&#123; next = first.getNext(); &#125; if(unsafe.compareAndSwapObject(this, headOffset,first,next))&#123; break; &#125; &#125; return first==null?null:first.getThread(); &#125; private Node getHead()&#123; return this.head; &#125; private static class Node&#123; volatile Node next; volatile Thread thread; public Node(Thread thread)&#123; this.thread = thread; &#125; public void setNext(Node next)&#123; this.next = next; &#125; public Node getNext()&#123; return next; &#125; public Thread getThread()&#123; return this.thread; &#125; &#125;&#125; 加锁失败的线程，调用insert方法将自己放入这个集合中，insert方法里将线程封装到Node中，然后使用cas操作将node添加到列表的头部。同样为了线程可见的问题，Node里的thread和next都用volatile修饰。加锁成功的线程，调用pop方法获得一个线程，进行唤醒，这里边同样使用了cas操作来保证线程安全。 接下来在看看锁的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyLock &#123; private volatile int state = 0; private ThreadList threadList = new ThreadList(); private static long stateOffset; private static Unsafe unsafe; static &#123; try &#123; Constructor&lt;Unsafe&gt; constructor = Unsafe.class.getDeclaredConstructor(new Class&lt;?&gt;[0]); constructor.setAccessible(true); unsafe = constructor.newInstance(new Object[0]); stateOffset = unsafe.objectFieldOffset(MyLock.class.getDeclaredField(&quot;state&quot;)); &#125;catch (Exception e)&#123; &#125; &#125; public void lock()&#123; if(compareAndSetState(0,1))&#123; &#125;else&#123; addNodeAndWait(); &#125; &#125; public void unLock()&#123; compareAndSetState(1,0); Thread thread = threadList.pop(); if(thread != null)&#123; LockSupport.unpark(thread); &#125; &#125; private void addNodeAndWait()&#123; //如果当前只有一个等待线程时，重新获取一下锁，防止永远不被唤醒。 boolean isOnlyOne = threadList.insert(Thread.currentThread()); if(isOnlyOne &amp;&amp; compareAndSetState(0,1))&#123; return; &#125; LockSupport.park(this);//线程被挂起 if(compareAndSetState(0,1))&#123;//线程被唤醒后继续竞争锁 return; &#125;else&#123; addNodeAndWait(); &#125; &#125; private boolean compareAndSetState(int expect,int update)&#123; return unsafe.compareAndSwapInt(this,stateOffset,expect,update); &#125;&#125; 线程调用lock方法进行加锁，cas将state从0修改1，修改成功则加锁成功，lock方法返回，否则调用addNodeAndWait方法将线程加入ThreadList队列，并使用LockSupport将线程挂起。(ThreadList的insert方法，返回一个boolean类型的值，用来处理一个特殊情况的，稍后再说。) 获得锁的线程执行完业务逻辑后，调用unLock方法释放锁，即通过cas操作将state修改回0，同时从ThreadList拿出一个等待线程，调用LockSupport的unpark方法，来将它唤醒。 将我们在《自己动手写把”锁”—锁的作用》的例子修改为如下，来测试下咱们的锁的效果： 1234567891011121314151617181920212223242526272829303132333435public class TestMyLock &#123; private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); private static MyLock myLock = new MyLock(); public static void main(String[] args)&#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;10000;i++)&#123; add(i); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; print(); &#125; &#125;); t1.start(); t2.start(); &#125; private static void add(int i)&#123; myLock.lock(); list.add(i); myLock.unLock(); &#125; private static void print()&#123; myLock.lock(); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; myLock.unLock(); &#125;&#125; ok,正常运行了，不在报错。 到这里咱们的一个简单地锁已经实现了。接下来我再把上边的，一个没讲的细节说一下。即如下这段代码： 1234boolean isOnlyOne = threadList.insert(Thread.currentThread()); if(isOnlyOne &amp;&amp; compareAndSetState(0,1))&#123; return; &#125; ThreadList的insert方法，在插入成功后，会判断当前链表中是否只有自己一个线程在等待，如果是则返回true。从而进入后边的if语句。这个逻辑的用意就是：如果只有自己一个线程在等待时，则试着通过cas操作重新获取锁，如果获取失败才进入阻塞等待。它是用来解决以下边界情况： 在只有线程A和线程B两个线程的时候，如果没有以上判断逻辑，线程B将有可能会永远处于阻塞不被唤醒。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写把“锁”之---LockSupport介绍]]></title>
    <url>%2F2018%2F01%2F07%2Fjava-lock4%2F</url>
    <content type="text"><![CDATA[本篇是《自己动手写把”锁”》系列技术铺垫的最后一个知识点。本篇主要讲解LockSupport工具类，它用来实现线程的挂起和唤醒。 LockSupport是Java6引入的一个工具类，它简单灵活，应用广泛。 一、简单俗话说，没有比较就没有伤害。这里咱们还是通过对比来介绍LockSupport的简单。在没有LockSupport之前，线程的挂起和唤醒咱们都是通过Object的wait和notify/notifyAll方法实现。写一段例子代码，线程A执行一段业务逻辑后调用wait阻塞住自己。主线程调用notify方法唤醒线程A，线程A然后打印自己执行的结果。 12345678910111213141516171819202122232425public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; final Object obj = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; int sum = 0; for(int i=0;i&lt;10;i++)&#123; sum+=i; &#125; try &#123; obj.wait(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(sum); &#125; &#125;); A.start(); //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法 Thread.sleep(1000); obj.notify(); &#125;&#125; 执行这段代码，不难发现这个错误： 12Exception in thread &quot;main&quot; java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method) 原因很简单，wait和notify/notifyAll方法只能在同步代码块里用(这个有的面试官也会考察)。所以将代码修改为如下就可正常运行了： 1234567891011121314151617181920212223242526272829public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; final Object obj = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; int sum = 0; for(int i=0;i&lt;10;i++)&#123; sum+=i; &#125; try &#123; synchronized (obj)&#123; obj.wait(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(sum); &#125; &#125;); A.start(); //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法 Thread.sleep(1000); synchronized (obj)&#123; obj.notify(); &#125; &#125;&#125; 那如果咱们换成LockSupport呢？简单得很，看代码： 1234567891011121314151617181920public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; int sum = 0; for(int i=0;i&lt;10;i++)&#123; sum+=i; &#125; LockSupport.park(); System.out.println(sum); &#125; &#125;); A.start(); //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法 Thread.sleep(1000); LockSupport.unpark(A); &#125;&#125; 直接调用就可以了，没有说非得在同步代码块里才能用。简单吧。 二、灵活如果只是LockSupport在使用起来比Object的wait/notify简单，那还真没必要专门讲解下LockSupport。最主要的是灵活性。上边的例子代码中，主线程调用了Thread.sleep(1000)方法来等待线程A计算完成进入wait状态。如果去掉Thread.sleep()调用，代码如下： 1234567891011121314151617181920212223242526272829public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; final Object obj = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; int sum = 0; for(int i=0;i&lt;10;i++)&#123; sum+=i; &#125; try &#123; synchronized (obj)&#123; obj.wait(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(sum); &#125; &#125;); A.start(); //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法 //Thread.sleep(1000); synchronized (obj)&#123; obj.notify(); &#125; &#125;&#125; 多运行几次上边的代码，有的时候能够正常打印结果并退出程序，但有的时候线程无法打印结果阻塞住了。原因就在于：主线程调用完notify后，线程A才进入wait方法，导致线程A一直阻塞住。由于线程A不是后台线程，所以整个程序无法退出。 那如果换做LockSupport呢？LockSupport就支持主线程先调用unpark后，线程A再调用park而不被阻塞吗？是的，没错。代码如下： 123456789101112131415161718192021public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; final Object obj = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; int sum = 0; for(int i=0;i&lt;10;i++)&#123; sum+=i; &#125; LockSupport.park(); System.out.println(sum); &#125; &#125;); A.start(); //睡眠一秒钟，保证线程A已经计算完成，阻塞在wait方法 //Thread.sleep(1000); LockSupport.unpark(A); &#125;&#125; 不管你执行多少次，这段代码都能正常打印结果并退出。这就是LockSupport最大的灵活所在。 总结一下，LockSupport比Object的wait/notify有两大优势： LockSupport不需要在同步代码块里 。所以线程间也不需要维护一个共享的同步对象，实现了线程间的解耦。 unpark函数可以先于park调用，所以不需要担心线程间的执行的先后顺序。 三、应用广泛LockSupport在Java的工具类用应用很广泛，咱们这里找几个例子感受感受。以Java里最常用的类ThreadPoolExecutor为例。先看如下代码： 1234567891011121314151617public class TestObjWait &#123; public static void main(String[] args)throws Exception &#123; ArrayBlockingQueue&lt;Runnable&gt; queue = new ArrayBlockingQueue&lt;Runnable&gt;(1000); ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5,5,1000, TimeUnit.SECONDS,queue); Future&lt;String&gt; future = poolExecutor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; TimeUnit.SECONDS.sleep(5); return &quot;hello&quot;; &#125; &#125;); String result = future.get(); System.out.println(result); &#125;&#125; 代码中我们向线程池中扔了一个任务，然后调用Future的get方法，同步阻塞等待线程池的执行结果。这里就要问了：get方法是如何组塞住当前线程？线程池执行完任务后又是如何唤醒线程的呢？ 咱们跟着源码一步步分析，先看线程池的submit方法的实现： 在submit方法里，线程池将我们提交的基于Callable实现的任务，封装为基于RunnableFuture实现的任务，然后将任务提交到线程池执行，并向当前线程返回RunnableFutrue。 进入newTaskFor方法，就一句话： 1return new FutureTask&lt;T&gt;(callable); 所以，咱们主线程调用future的get方法就是FutureTask的get方法，线程池执行的任务对象也是FutureTask的实例。 接下来看看FutureTask的get方法的实现： 比较简单，就是判断下当前任务是否执行完毕，如果执行完毕直接返回任务结果，否则进入awaitDone方法阻塞等待。 awaitDone方法里，首先会用到上节讲到的cas操作，将线程封装为WaitNode，保存下来，以供后续唤醒线程时用。再就是调用了LockSupport的park/parkNanos组塞住当前线程。 上边已经说完了阻塞等待任务结果的逻辑，接下来再看看线程池执行完任务，唤醒等待线程的逻辑实现。 前边说了，咱们提交的基于Callable实现的任务，已经被封装为FutureTask任务提交给了线程池执行，任务的执行就是FutureTask的run方法执行。如下是FutureTask的run方法： c.call()就是执行我们提交的任务，任务执行完后调用了set方法，进入set方法发现set方法调用了finishCompletion方法，想必唤醒线程的工作就在这里边了，看看代码实现吧： 没错就在这里边，先是通过cas操作将所有等待的线程拿出来，然后便使用LockSupport的unpark唤醒每个线程。 在使用线程池的过程中，不知道你有没有这么一个疑问：线程池里没有任务时，线程池里的线程在干嘛呢？ 看过我的这篇文章《线程池的工作原理与源码解读》的读者一定知道，线程会调用队列的take方法阻塞等待新任务。那队列的take方法是不是也跟Future的get方法实现一样呢？咱们来看看源码实现。 以ArrayBlockingQueue为例，take方法实现如下： 与想象的有点出入，他是使用了Lock的Condition的await方法实现线程阻塞。但当我们继续追下去进入await方法，发现还是使用了LockSupport： 限于篇幅，jdk里的更多应用就不再追下去了。 四、LockSupport的实现学习要知其然，还要知其所以然。接下来不妨看看LockSupport的实现。 进入LockSupport的park方法，可以发现它是调用了Unsafe的park方法，这是一个本地native方法，只能通过openjdk的源码看看其本地实现了： 它调用了线程的Parker类型对象的park方法，如下是Parker类的定义： 类中定义了一个int类型的_counter变量，咱们上文中讲灵活性的那一节说：可以先执行unpark后执行park，就是通过这个变量实现。看下park方法的实现代码(由于方法比较长就不整体截图了)： park方法会调用Atomic::xchg方法，这个方法会原子性的将_counter赋值为0，并返回赋值前的值。如果调用park方法前，_counter大于0，则说明之前调用过unpark方法，所以park方法直接返回。接着往下看： 实际上Parker类用Posix的mutex，condition来实现的阻塞唤醒。如果对mutex和condition不熟，可以简单理解为mutex就是Java里的synchronized，condition就是Object里的wait/notify操作。 park方法里调用pthread_mutex_trylock方法，就相当于Java线程进入Java的同步代码块，然后再次判断_counter是否大于零，如果大于零则将_counter设置为零。最后调用pthread_mutex_unlock解锁，相当于Java执行完退出同步代码块。如果_counter不大于零，则继续往下执行pthread_cond_wait方法，实现当前线程的阻塞。 最后再看看unpark方法的实现吧，这块就简单多了，直接上代码： 图中的1和4就相当于Java的进入synchronized和退出synchronized的加锁解锁操作，代码2将_counter设置为1，同时判断先前_counter的值是否小于1，即这段代码：if(s&lt;1)。如果不小于1，则就不会有线程被park，所以方法直接执行完毕，否则就会执行代码3，来唤醒被阻塞的线程。 通过阅读LockSupport的本地实现，我们不难发现这么个问题：多次调用unpark方法和调用一次unpark方法效果一样，因为都是直接将_counter赋值为1，而不是加1。简单说就是：线程A连续调用两次LockSupport.unpark(B)方法唤醒线程B，然后线程B调用两次LockSupport.park()方法， 线程B依旧会被阻塞。因为两次unpark调用效果跟一次调用一样，只能让线程B的第一次调用park方法不被阻塞，第二次调用依旧会阻塞。 到这里,自己实现一把“锁”用到的技术点都已经介绍完了，甚至本节还介绍了锁的具体实现，相信即使没有最后一篇介绍怎么实现“锁”，大家也能动手写个锁了。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>locksupport</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写把”锁”之---原子性操作]]></title>
    <url>%2F2018%2F01%2F06%2Fjava-lock3%2F</url>
    <content type="text"><![CDATA[所谓的原子性，就是在执行过程中不会被线程调度机制打断的操作，这种操作从开始就一直运行到结束，中间不存在任何上下文切换。 还是以上篇讲到的x++操作为例。这是一个典型的‘读改写’的操作，在多线程的情况下，必须需要硬件的支持来保证‘读改写’的原子性，底层原理可以简单理解，通过锁总线的方式来实现。不过这里咱们不说硬件，咱们先研究下Java是如何原子性实现++操作的。 在Java中，如果要实现一个在多线程下正常工作的累加计数器，首先想到的就是并发包里的AtomicXXX类，如一下例子代码： 12345678910111213141516171819202122232425public class TestAtomic &#123; private static AtomicInteger couter = new AtomicInteger(0); public static void main(String[] args)throws Exception &#123; Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0;i&lt;1000;i++) incr(); &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0;i&lt;1000;i++) incr(); &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(couter.get()); &#125; public static void incr()&#123; couter.incrementAndGet(); &#125;&#125; 这里我们通过AtomicInteger实现累加器，两个线程各执行了一千次++操作，最后正常输出结果2000。 通过分析AtomicInteger的源码，我们可以发现，其内部用来保存具体数值的变量是这么定义的： 1private volatile int value; 它通过volatile来实现了value在多线程之间的可见性，即线程A改变了value的值，线程B读取value时读到的是被修改后的值。 但是之前也说到了，volatile修饰的变量，仅通过++操作是无法实现原子性的，原因上篇说了这里就不多说了。 再来看看如果实现多线程间的原子性++操作，进入AtomicInteger的incrementAndGet方法，他通过调用Unsafe的getAndAddInt方法来实现： 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; Unsafe是Java提供用来访问系统底层的工具类，它大致有这几个能力： 直接分队释放堆外内存。Java的直接内存就是通过这个来实现。 线程的挂起和恢复。后边咱们要说的LockSupport就是通过这个实现。 CAS操作。即Compare And Swap，简单地说就是比较并交换。在保证‘读改写’一致性上极其有用。它在写操作时会先比较当前内存里的值是否和改之前读的值是否一致，如果一致则修改成功，不一致则修改失败。 Unsafe在CAS操作一个变量时，用到了这个变量在类中的偏移位置。如AtomicInteger操作value变量时通过如下代码先得到valueOffset： 123456static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 进入到Unsafe的getAndAddInt方法： 123456int var5;do &#123; var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5; 这里不断读取value变量的值，然后通过compareAndSwapInt操作，即CAS操作，将修改后的值写回去，直到修改成功退出循环。 说到这里应该把AtomicInteger实现原子性++的操作说清楚了。比较简单，总结起来就两点： 通过volatile实现变量value的变更对线程可见 通过Unsafe的CAS操作，避免了一个线程的修改覆盖另一个线程的修改，从而实现结果上的一致性。 这里我们不妨再看看Unsafe的comareAndSwapInt方法的实现，这个方法定义如下： 1public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 这是一个用native修饰的本地方法，通过openjdk的源码可以找到其本地实现代码： 这里可以看到，它是先计算出了要修改的变量地址，然后调用Atomic的cmpxchg方法实现cas操作。我们继续跟踪cmpxchg方法： 这是x86平台下的源码实现，可以看到它用了cmpxchgl汇编指令。也就是说，原子性操作是要硬件层面的支持。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>cas</tag>
        <tag>原子性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写把”锁”之---JMM和volatile]]></title>
    <url>%2F2018%2F01%2F02%2Fjava-lock2%2F</url>
    <content type="text"><![CDATA[一、JAVA内存模型关于Java内存模型的文章，网上真的数不胜数。在这里我就不打算说的很详细、很严谨了。只力求大家能更好的理解和运用，为后边的技术点做铺垫。内存模型并不是Java独有的概念，而是我们的计算机硬件平台的一个概念。内存模型描述了程序中变量如何在从内存读出、以及何时写会内存的底层细节。 我们知道，程序运行其实就是CPU和内存的频繁交互的过程。随着CPU的快速发展，CPU的执行速度越来越快，但是内存却很难跟上CPU的执行速度，为了解决这一矛盾，CPU厂商就为每颗CPU加了高速缓存，用来缓解这个速度不匹配的问题。因此，CPU和内存的交互变成了这个样子： 以上只是在CPU和内存之间加了个高速缓存，其实也还没什么问题。那内存模型这个概念是怎么产生的呢？继续往下看。 CPU虽然在不停的发展，但单个CPU的主频速度不可能无限制的增长，为了进一步提高计算性能就引入了多核技术。由于每个cpu都有自己的高速缓存，当多个CPU操作同一个内存数据时，就产生了缓存不一致的问题。如下图： 为了解决这个不一致的问题，就需要处理器在运行时要遵循某些协议，这类协议包括MSI、MESI、MOSI等等。到这里就有了内存模型这个概念，它就是用来描述数据在各个高级缓存以及内存之间的交互细节。不同的硬件处理器架构，就会有不同的内存模型。所以用c/c++开发多线程程序时，就需要考虑不同操作平台下的内存模型。 所幸我们是学Java的，Java平台为了屏蔽不同硬件平台的不同内存模型给开发人员带来的成本，引入了Java内存模型，即JAVA Memory Model，简称JMM。 要想深入掌握JAVA多线程并发编程，Java内存模型是必须要了解的。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。直白点说就是：同一个变量，被多个cpu上执行的多个线程访问，每个cpu的高速缓存都缓存了这个变量，当某个线程修改了高速缓存里的变量，何时通知给其他的cpu线程让它可见，以及何时将变量同步回内存(主存)。如下图： Java虚拟机的内存模型和计算机硬件的内存模型基本一致。在Java内存模型中，分为线程私有的本地内存和线程共享的主内存，线程在读写变量时会把主内存里的变量缓存到本地内存，换句话说，本地内存存放了主内存中变量的副本。主内存和本地内存其实是一种逻辑上的划分，并不是实际的物理内存。 这里需要强调一下，这里的变量指的是分配到堆上的变量，即线程之间可以共享的变量。本地变量是线程私有的，所以不会有可见性问题。 二、volatileJava内存模型中说到了线程间共享变量的可见性问题。可见性问题其实就是缓存不一致的问题。如下图： 线程B读取变量X，并缓存到了自己的本地内存中，线程A也将变量X缓存到本地内存中并修改为2，这时线程B并不知道变量X修改为2。这就是线程间不可见的问题。为了解决这个问题，就引入了volatile关键字，被volatile修饰的变量将不会在本地内存缓存，线程直接通过主内存来读写变量。虽然解决了不可见的问题，但也是以牺牲性能为代价的。 volatile关键字相信你已经理解了，但是在Java中volatile并不仅仅是这个功能。在这里我通过与c语言中的volatile对比扩展下。有的时候我们可能会面临这么个场景，线程1执行某些业务逻辑，线程2判断线程1是否执行完，执行完了则线程2执行另一个逻辑，如下伪代码： 我们通过一个flag变量来标识线程1是否执行完相关逻辑，为了保证flag的改变对线程2可见，这里使用了volatile关键字修饰。如果这个伪代码采用Java实现，这是没问题的，如果c实现，则就会有坑。这个坑主要是源于指令重排。为了提高执行效率减少内存的交互，编译器会根据情况对执行的指令做一个重排序。所以线程1中执行相关业务逻辑后，再将flag设置为true的逻辑，极有可能重排为：先设置flag=true然后再执行相关业务逻辑。这也是c语言为啥不提倡使用volatile的原因。 但是为什么在Java中就不会有这个坑呢，难道Java没有指令重排序吗？当然不是，Java也会有重排序，不过Java对volatile做了如下的极大增强： 所有对volatile变量的写操作之前的针对其他变量的读写操作，经过编译器、cpu优化后，都不会被重排到对voltile变量的写操作之后。 所有对volatile变量的读操作之后的针对其他变量的读写操作，经过编译器、cpu优化后，都不会被重排到对voltile变量的读操作之前。 面试中，有面试官比较喜欢问这么一个问题：能否用volatile修饰的整数变量n，通过n++操作实现计数的功能？这个问题就是考查应试者对volatile的理解。我这里简单地说一下。答案肯定是不能。volatile实现的是线程间共享变量的可见性，并不是原子性操作。++操作其实可以拆分为这么几个步骤： 读取主内存里的变量 cpu完成变量的++,然后写会主内存。 所以可以想象这么一个执行顺序： 线程A读取volatile变量X=0 线程B读取volatile变量X=0 线程A完成++操作，然后将X=1写回主存。 线程B也完成++操作将X=1写回主存。 在这么一个执行顺序下，对X进行了++两次，但值却只增加了1。 关于如何实现原子性操作，我将在下一节进行讨论。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
        <tag>可见性</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写把”锁”之---锁的作用]]></title>
    <url>%2F2017%2F12%2F31%2Fjava-lock1%2F</url>
    <content type="text"><![CDATA[前序这是一个系列文章，前边几篇比较基础，主要为了后续做准备。熟悉的朋友可以直接跳过看后续的文章。 本主题很重要，学完这个系列，你将会对Java并包有一个透彻的原理性的认识。线程池技术、阻塞队列、信号量、原子性操作等等所用的基础技术都会在这系列的文章中讲到。大家可以提前学习下CountDownLatch的使用，在学完这系列文章后，我将会布置一个作业：自己动手实现一个CountDownLatch。 正文都知道，现在处理器的核数越来越多，为充分利用其计算资源，服务端编程通常会用上多线程技术。利用多线程技术可以同时进行计算任务，从而提高的服务的并发度。 但是，当多线程对同一块内存资源进行操作时，如果不对线程进行“排队”，其结果将是混乱不堪预测额。 这里说的“排队”就是通常说的线程同步。当一个线程在操作这个资源时，后来的线程等待上一个线程操作完才能开始。 举个代码栗子： 123456789101112131415161718192021222324252627282930public class TestMyLock &#123; private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args)&#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i=0;i&lt;10000;i++)&#123; add(i); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; print(); &#125; &#125;); t1.start(); t2.start(); &#125; private static void add(int i)&#123; list.add(i); &#125; private static void print()&#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 以上我们创建了两个线程：t1和t2。t1循环一万次向list里边添加数字，t2遍历list并将内容打印到控制台。执行后得到如下错误： 原因很简单，就是两个线程同时操作list而没有进行线程同步导致的报错。我们修改下代码再来看一下。add和print方法修改为如下： 123456789private synchronized static void add(int i)&#123; list.add(i);&#125;private synchronized static void print()&#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 我们仅仅是在add和print方法前加入了synchronized修饰词，程序便可以正常执行了 synchronized关键字是Java内置的同步锁。两个线程会竞争对synchronized绑定的同步对象加锁，加锁失败的线程会阻塞等待加锁成功的线程执行完毕。由于add和print方法都是静态方法，这里synchronized绑定的同步对象就是TestMyLock.class。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>同步</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[大家好，我是清泉。欢迎来到我的个人技术博客。 本人多年从事互联网开发，以Java后端开发为主，其它为辅。先后在某上市游戏公司做页游服务端开发，也曾在创业公司做移动APP后端架构设计，目前在阿里巴巴从事资深研发的工作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2Freading%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
